//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  signUpAll(body?: SignUpDTO | undefined): Promise<ErrorDtoSignUpResponseDtoEitherData[]> {
    let url_ = this.baseUrl + "/api/auth/sign-up";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "text/plain"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignUpAll(_response);
    });
  }

  protected processSignUpAll(response: Response): Promise<ErrorDtoSignUpResponseDtoEitherData[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorDtoSignUpResponseDtoEitherData[];
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationFailedErrorDTO;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ErrorDtoSignUpResponseDtoEitherData[]>(null as any);
  }

  /**
   * @return Success
   */
  async me(): Promise<string | { success: boolean }> {
    return { success: true };
    let url_ = this.baseUrl + "/api/auth/me";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
        "Accept": "text/plain"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMe(_response);
    });
  }

  protected processMe(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  confirmEmail(body?: ConfirmEmailDTO | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/auth/confirm-email";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConfirmEmail(_response);
    });
  }

  protected processConfirmEmail(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  signIn(body?: SignInDTO | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/auth/sign-in";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignIn(_response);
    });
  }

  protected processSignIn(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  refreshToken(body?: RefreshTokenDTO | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/auth/refresh-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRefreshToken(_response);
    });
  }

  protected processRefreshToken(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resendConfirmationCode(body?: ResendConfirmationUrlDTO | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/auth/resend-confirmation-code";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processResendConfirmationCode(_response);
    });
  }

  protected processResendConfirmationCode(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  forgotPassword(body?: ForgotPasswordDTO | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/auth/forgot-password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processForgotPassword(_response);
    });
  }

  protected processForgotPassword(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body?: ResetPasswordDTO | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/auth/reset-password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processResetPassword(_response);
    });
  }

  protected processResetPassword(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param userId (optional)
   * @return Success
   */
  checkDaily(userId?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/daily/check-daily?";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCheckDaily(_response);
    });
  }

  protected processCheckDaily(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param authorization_Code (optional)
   * @return Success
   */
  signUp(authorization_Code?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/google-auth/sign-up";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
        "Authorization-Code": authorization_Code !== undefined && authorization_Code !== null ? "" + authorization_Code : "",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignUp(_response);
    });
  }

  protected processSignUp(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param authorization_Code (optional)
   * @return Success
   */
  signIn2(authorization_Code?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/google-auth/sign-in";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
        "Authorization-Code": authorization_Code !== undefined && authorization_Code !== null ? "" + authorization_Code : "",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignIn2(_response);
    });
  }

  protected processSignIn2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param userId (optional)
   * @param body (optional)
   * @return Success
   */
  nutritionGoalPOST(userId?: string | undefined, body?: NutritionGoalDTO | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/nutrition-goal?";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processNutritionGoalPOST(_response);
    });
  }

  protected processNutritionGoalPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param userId (optional)
   * @return Success
   */
  nutritionGoalGET(userId?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/nutrition-goal?";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processNutritionGoalGET(_response);
    });
  }

  protected processNutritionGoalGET(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param userId (optional)
   * @return Success
   */
  userMeal(userId?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/meal/user-meal?";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserMeal(_response);
    });
  }

  protected processUserMeal(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param userId (optional)
   * @param date (optional)
   * @param mealId (optional)
   * @return Success
   */
  allProducts(userId?: string | undefined, date?: Date | undefined, mealId?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/meal/all-products?";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (date === null)
      throw new Error("The parameter 'date' cannot be null.");
    else if (date !== undefined)
      url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
    if (mealId === null)
      throw new Error("The parameter 'mealId' cannot be null.");
    else if (mealId !== undefined)
      url_ += "mealId=" + encodeURIComponent("" + mealId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAllProducts(_response);
    });
  }

  protected processAllProducts(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param userId (optional)
   * @param mealId (optional)
   * @return Success
   */
  nutrition(userId?: string | undefined, mealId?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/meal/nutrition?";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (mealId === null)
      throw new Error("The parameter 'mealId' cannot be null.");
    else if (mealId !== undefined)
      url_ += "mealId=" + encodeURIComponent("" + mealId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processNutrition(_response);
    });
  }

  protected processNutrition(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param userId (optional)
   * @param dailyId (optional)
   * @return Success
   */
  meal(userId?: string | undefined, dailyId?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/meal/meal?";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (dailyId === null)
      throw new Error("The parameter 'dailyId' cannot be null.");
    else if (dailyId !== undefined)
      url_ += "dailyId=" + encodeURIComponent("" + dailyId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "PUT",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMeal(_response);
    });
  }

  protected processMeal(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param name (optional)
   * @param volume (optional)
   * @param mealId (optional)
   * @return Success
   */
  productPOST(name?: string | undefined, volume?: number | undefined, mealId?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/product?";
    if (name === null)
      throw new Error("The parameter 'name' cannot be null.");
    else if (name !== undefined)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    if (volume === null)
      throw new Error("The parameter 'volume' cannot be null.");
    else if (volume !== undefined)
      url_ += "volume=" + encodeURIComponent("" + volume) + "&";
    if (mealId === null)
      throw new Error("The parameter 'mealId' cannot be null.");
    else if (mealId !== undefined)
      url_ += "mealId=" + encodeURIComponent("" + mealId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processProductPOST(_response);
    });
  }

  protected processProductPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param productId (optional)
   * @param volume (optional)
   * @return Success
   */
  productPUT(productId?: string | undefined, volume?: number | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/product?";
    if (productId === null)
      throw new Error("The parameter 'productId' cannot be null.");
    else if (productId !== undefined)
      url_ += "productId=" + encodeURIComponent("" + productId) + "&";
    if (volume === null)
      throw new Error("The parameter 'volume' cannot be null.");
    else if (volume !== undefined)
      url_ += "volume=" + encodeURIComponent("" + volume) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "PUT",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processProductPUT(_response);
    });
  }

  protected processProductPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param productId (optional)
   * @return Success
   */
  productDELETE(productId?: string | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/product?";
    if (productId === null)
      throw new Error("The parameter 'productId' cannot be null.");
    else if (productId !== undefined)
      url_ += "productId=" + encodeURIComponent("" + productId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processProductDELETE(_response);
    });
  }

  protected processProductDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export interface ConfirmEmailDTO {
  userId?: string;
  url?: string | undefined;
}

export enum ErrorCode {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
}

export interface ErrorDtoSignUpResponseDtoEitherData {
}

export interface ForgotPasswordDTO {
  email?: string | undefined;
}

export interface NutritionGoalDTO {
  userId?: string;
  calories?: number;
  protein?: number;
  fat?: number;
  carbs?: number;
}

export interface RefreshTokenDTO {
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
}

export interface ResendConfirmationUrlDTO {
  userId?: string;
}

export interface ResetPasswordDTO {
  email?: string | undefined;
  token?: string | undefined;
  newPassword?: string | undefined;
}

export interface SignInDTO {
  email?: string | undefined;
  password?: string | undefined;
}

export interface SignUpDTO {
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  password?: string | undefined;
}

export interface ValidationFailedErrorDTO {
  message?: string | undefined;
  error?: ErrorCode;
  body?: { [key: string]: string[]; } | undefined;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
  if (result !== null && result !== undefined)
    throw result;
  else
    throw new ApiException(message, status, response, headers, null);
}
